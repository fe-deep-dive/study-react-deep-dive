# 14장 웹사이트 보안을 위한 리액트와 웹페이지 보안 이슈

## 14.1 리액트에서 발생하는 크로스 사이트 스크립팅(XSS)

크로스 사이트 스크립팅(Cross-Site Scripting, XSS)이란, 웹사이트 개발자가 아닌 제3자가 웹사이트에 **악성 스크립트를 삽입**해 실행할 수 있는 취약점을 의미한다.

이는 사용자의 데이터를 탈취하거나 변경하는 등의 위험성이 있다. 그렇다면 리액트에서는 이 XSS 이슈가 어떻게 발생할 수 있을까?

### 14.1.1 dangerouslySetInnerHTML prop

dangerouslySetInnerHTML은 특정 브라우저 DOM의 **innerHTML을** 특정한 내용으로 **교체**할 수 있는 방법이다.

일반적으로 사용자가 입력한 내용을 브라우저에 표시하는 용도로 사용된다.

dangerouslySetInnerHTML은 오직 __html을 키로 가지고 있는 개체만 인수로 받을 수 있으며, 인수로 넘겨받은 문자열을 DOM에 그대로 표시한다.

그러나 이 dangerouslySetInnerHTML의 위험성은 인수로 받는 문자열에 제한이 없다는 것이다.

```jsx
const html = `<span><svg/onload=alert(origin)></span>`

function App() {
  return <div dangerouslySetInnerHTML={{ __html: html }} />
}

export default App
```

위 코드를 방문하면 다음과 같이 origin이 alert로 나타나게 된다.

![image](https://github.com/user-attachments/assets/d19b1bbd-b14d-40b1-a4b9-66094a79f558)

그러므로 여기에 넘겨주는 문자열 값은 한 번 더 검증이 필요하다.

### 14.1.2 useRef를 활용한 직접 삽입

dangerouslySetInnerHTML과 비슷한 방법으로 DOM에 직접 내용을 삽입할 수 있는 방법으로 useRef가 있다. useRef 또한 innerHTML에 보안 취약점이 있는 스크립트를 삽입하면 동일한 문제가 발생한다.

\<script\>나 svg/onload를 사용하는 방식 외에도 \<a\> 태그에 잘못된 href를 삽입하거나 onclick, onload 등 이벤트를 활용하는 등 여러 가지 방식의 XSS가 있다.


### 14.1.3 리액트에서 XSS 문제를 피하는 방법

리액트에서 XSS를 피하는 가장 확실한 방법은 제3자가 삽입할 수 있는 HTML을 안전한 HTML 코드로 한 번 치환하는 것이다. 이러한 과정을 <strong>새니타이즈(sanitize) 또는 이스케이프(escape)</strong>라고 하는데, npm에 있는 유명한 새니타이즈 라이브러리로는 다음과 같은 것이 있다.

- DOMpurity(https://github.com/cure53/DOMPurify)
- sanitize-html(https://github.com/apostrophecms/sanitize-html)
- js-xss(https://github.com/leizongmin/js-xss)

sanitize-html을 사용한 예제이다.
```js
import sanitizeHtml, { IOptions as SanitizeOptions } from 'sanitize-html'
// 허용하는 태그
const allowedTags = [
  'div',
  'p',
  'span',
  'iframe',
  'img',
  'a',
  ...
]

// 위 태그에서 허용할 모든 속성
const defaultAttributes = ['style', 'class']

// 허용할 iframe 도메인
const allowedIframeDomains = ['naver.com']

// 허용되는 태그 중 추가로 허용할 속성
const allowedAttributeForTags: {
  [key in (typeof allowedTags)[number]]: Array<string>
} = {
  iframe: ['src', 'allowfullscreen', 'scrolling', 'frameborder', 'allow'],
  img: ['src', 'alt'],
  a: ['href'],
}

// allowedTags, allowedAttributeForTags, defaultAttributes를 기반으로
// 허용할 태그와 속성을 정의
const allowedAttributes = allowedTags.reduce<
  SanitizeOptions['allowedAttributes']
>((result, tag) => {
  const additionalAttrs = allowedAttributeForTags[tag] || []
  return { ...result, [tag]: [...additionalAttrs, ...defaultAttributes] }
}, {})

const saniizedOptions: SanitizeOptions = {
  allowedTags,
  allowdAttributes,
  allowedIframeDomains,
  allowIframeRelativeUrls: true,
}

const html = `<span><svg/onload=alert(origin)></span>`

function App() {
  // 위 옵션을 기반으로 HTML을 이스케이프한다.
  // svg는 허용된 태그가 아니므로 <span></span>만 남는다.

  const sanitizedHtml = sanitizeHtml(html, sanitizedOpitons)

  return <div dangerouslySetInnerHTML={{ __html: sanitizedHtml }}></div>
}
```

보여줄 때뿐만 아니라 사용자가 콘텐츠를 저장할 때도 한번 이스케이프 과정을 거치는 것이 더 효율적이고 안전하다.

이러한 치환 과정은 되도록 서버에서 수행하는 것이 좋다. 서버는 '클라이언트에서 사용자가 입력한 데이터는 일단 의심한다'라는 자세로 클라이언트의 POST 요청에 있는 HTML을 이스케이프하는 것이 제일 안전하다.


게시판 같은 페이지가 없다고 하더라도 쿼리스트링에 있는 내용을 그대로 실행하거나 보여주는 경우에도 보안 취약점이 발생할 수 있다.

```jsx
import { useRouter } from 'next/router'

function App() {
  const router = useRouter()
  const query = router.query
  const html = query?.html?.toString() || ''

  return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```

따라서 개발자는 자신이 작성한 코드가 아닌 모든 외부 코드를 위험한 코드로 간주하고 이를 적절하게 처리하는 것이 좋다.

> 리액트의 JSX 데이터 바인딩
>
> 왜 dangerouslySetInnerHTML이라는 속성이 별도로 존재하는 걸까?
>
> 기본적으로 리액트는 XSS를 방어하기 위한 이스케이프 작업이 존재하기 때문이다.
>
> ```jsx
> const html = `<span><svg/onload=alert(origin)></span>`
> 
> function App() {
>   return <div id={html}>{html}</div>
> }
> ```
> 위 코드를 실행해보면 svg의 onload는 실행되지 않고 다음과 같이 렌더링된다.
>
> ![image](https://github.com/user-attachments/assets/fa4346cc-b8a9-4bbb-97c1-e0c857a866cd)
>
> 즉, \<div\>{html}\</div\>와 같이 HTML에 직접 표시되는 textContent와 HTML 속성값에 대해서는 리액트가 기본적으로 이스케이프 작업을 해주는 것을 알 수 있다.

## 14.2 getServerSideProps와 서버 컴포넌트를 주의하자

서버에는 일반 사용자에게 노출되면 안 되는 정보들이 담겨 있기 때문에 SSR과 서버 컴포넌트로 브라우저에 정보를 내려줄 때는 조심해야 한다.

따라서 getServerSideProps가 반환하는 값 또는 서버 컴포넌트가 클라이언트 컴포넌트에 반환하는 props는 반드시 필요한 값으로만 철저하게 관리되어야 한다.

예를 들어, 쿠키 정보를 내려줄 때 클라이언트에 반드시 필요한 token 값만 제한적으로 반환하고, 값이 없을 때 예외 처리할 리다이렉트도 모두 서버에서 처리한다.

이러한 접근법은 리덕스에서 서버 사이드에서 가져온 상태로 가져오는 window.__PRELOADED_STATE__와 같은 값을 초기화할 때도 적용된다. window.__PRELOADED_STATE__의 값은 XSS에 취약할 수 있기 때문에 반드시 새니타이즈를 거치고 꼭 필요한 값만 제공해야 한다.

## 14.3 \<a\> 태그의 값에 적절한 제한을 둬야 한다.

## 14.4 HTTP 보안 헤더 설정하기

### 14.4.1 Strict-Transport-Security

### 14.4.2 X-XSS-Protection

### 14.4.3 X-Frame-Options

### 14.4.4 Permissions-Policy

### 14.4.5 X-Content-Type-Options

### 14.4.6 Referrer-Policy

### 14.4.7 Content-Security-Policy

> *-src

> form-action

### 14.4.8 보안 헤더 설정하기

> Next.js

> NGINGX


### 14.4.9 보안 헤더 확인하기

## 14.5 취약점이 있는 패키지의 사용을 피하자

## 14.6 OWASP Top 10

## 14.7 정리
