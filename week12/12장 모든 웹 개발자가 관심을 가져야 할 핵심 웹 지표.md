# 12장: 모든 웹 개발자가 관심을 가져야 할 핵심 웹 지표

## 12.1 웹사이트와 성능

2019년, 미국 디지털 마케팅 회사 `Protent`의 조사 결과는 다음과 같다.

1. 1초 내로 로딩되는 사이트는 5초 내로 로딩되는 사이트보다 구매로 이어지는 고객 비율이 2.5배 더 높다.
2. 0 ~ 5초 범위에서, 1초 로딩이 늦어질수록 전환율은 4.42%씩 떨어진다. (5초 = 약 20%)
3. 소비자의 70%는 페이지 속도가 온라인 커머스에서 중요하다고 밝혔으며, 빠르다면 애니메이션이나 동영상은 필요 없다고 밝혔다.

구글에서도 비슷한 웹사이트 성능에 관한 통계를 내놓았다.

1. 전체 웹페이지를 표시하는 데 필요한 최적 리소스 요청 수는 약 50회 미만
2. 평균적으로 웹페이지 전체를 요청하는 데 15.3초 소요
3. 페이지 로드 시간이 1초에서 10초로 늘어날수록 사이트 이탈율이 123% 증가

이러한 점에서 보통 개발자는 성능 문제에 관심을 갖지 않는다.  
왜 그러냐면..

1. 개발자의 기기는 보통 일반 사용자보다 성능이 뛰어나서 문제를 겪지 못한다.
2. 성능 개선 작업은 쉽지도 재밌지도 않으며, 서비스 개발보다 눈에 띄는 성능 향상을 기대하기도 어렵다.

## 12.2 핵심 웹 지표란?

`Core Web Vital`로 알려져 있는 이 지표는, 구글에서 만든 웹사이트에서 뛰어난 사용자 경험을 제공하는 데 필수적인 지표다.

### 핵심 웹 지표

- 최대 콘텐츠풀 페인트 (`LCP` : Largest Contentful Paint)
- 최초 입력 지연 (`FID` : First Input Delay)
- 누적 레이아웃 이동 (`CLS` : Cumulative Layout Shift)

### 그 외 지표

- 최초 바이트까지의 시간 (`TTFB` : Time To First Byte)
- 최초 콘텐츠풀 시간 (`FCP` : First Contentful Paint)

<img width="1080" alt="image" src="https://github.com/user-attachments/assets/4546732e-964e-455a-9c32-7a2c7e515725">

`Next.js`의 `EsLint`에서도 기본적으로 이와 같은 지표를 제공한다.

## 12.3 최대 콘텐츠풀 페인트 (LCP)

### 정의

> 페이지가 처음으로 로드를 시작한 시점부터 뷰포트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간

뷰포트 내부에서 가장 큰 이미지 또는 텍스트란?

- `<img>`
- `<svg>` 내부의 `<image>`
- `poster` 속성을 사용하는 `<video>`
- `url()`을 통해 불러온 배경 이미지가 있는 요소
- 텍스트와 같이 인라인 텍스트 요소를 포함하는 블록 레벨 요소 (`<p>`, `<div>` 등)

이러한 엘리먼트가 언제 노출되는지 확인하는 정확한 시점 = **각 엘리먼트가 등장한 시점부터 텍스트 또는 이미지가 완전히 로딩되는 시점**

→ **뷰포트 내부에서 가장 큰 영역을 차지하는 요소가 렌더링되는 데 얼마나 걸리는지를 측정한 지표**

만약 뷰포트 영역 밖이라면, 해당 크기는 고려하지 않는다.

### 의미

> 웹페이지가 로딩이 완료되어 사용자에게 노출되기까지 걸리는 시간이란?

`DOMContentLoaded` 이벤트

- HTML 문서를 완전히 불러오고 파싱했을 때 발생하는 이벤트
- 스타일시트, 이미지, 하위 프레임의 로딩은 기다리지 않기 때문에, "페이지가 로딩되었다"라고 볼 수는 없다.

#### 사용자가 페이지 로딩을 체감하기 위해 꼭 페이지가 완전히 로딩될 필요는 없다.

- 코드 수가 1만 줄이어도 `IntersectionObserver`로 구현되었다면, 사용자에게 노출되는 부분만 로딩된다면 로딩이 완료되었다고 느낄 것이다.
- 즉, 사용자에게 `로딩`이란, 뷰포트에 보이는 영역을 기준으로 하기 때문에, **뷰포트에 메인 컨텐츠가 전달되는 속도**를 기준으로 측정할 수 있다.

→ "사용자에게 페이지의 정보를 화면에 전달하는 속도" 를 판단하기 위해 만들어진 지표 = `LCP`

### 기준 점수

- 2.5초 내로 응답이 오면 `Good`
- 4초 내로 응답이 오면 `Needs Improvement`
- 그 이상 `Poor`

### 개선 방안

1. 텍스트는 언제나 옳다.

- 가능한 한 `LCP` 예상 영역에는 이미지가 아닌 문자열을 넣을 것

2. 이미지는 어떻게 불러올 것인가?

→ `img`, `video` 가 이미지 노출 속도가 빠르다.

- `img`

  - 이미지는 브라우저의 `preload scanner`에 의해 빠르게 요청이 일어난다.
  - HTML 파싱이 완료되지 않더라도, 병렬적으로 리소스를 다운로드하므로 `LCP` 요소를 불러오기 적합하다.

- `svg` 내부의 `img`

  - `preload scanner`에 발견되지 않아 병렬적 다운로드가 일어나지 않는다.

- `video`의 `poster`

  - `poster` : 사용자가 `video` 요소를 재생하거나 탐색하기 전까지 노출되는 요소
  - `preload scanner`에 의해 먼저 발견되어, `img`와 같은 성능을 보인다.
  - `poster`가 없는 `video`는 실제로 비디오를 로딩해, 첫 프레임을 사용한다.
    - 즉 성능이 하락하므로 `LCP`에 영향을 받을 것 같다면 `poster`를 사용할 것

- `background-image`
  - `url(): background-image`를 비롯해, **css 리소스는 항상 느리다.**

### 그 밖에 주의 사항

- 이미지 무손실 압축
  - 웹서비스 이미지는 가능한 한 무손실 형식으로 압축하여, 최소한의 용량으로 서비스할 것
- `loading=lazy` 주의
  - 리소스를 중요하지 않다고 표시하고, 필요할 때만 로드하는 전략
  - `LCP`의 이미지를 중요하지 않다고 분류하면..?
- `fadein` 같은 각종 애니메이션
  - `fadeIn ease 10s` 등의 애니메이션 처리를 한다면, `LCP`도 그 시간만큼 느려진다.
- 클라이언트에서 빌드하지 말 것
  - 서버에서 빌드한 HTML을 `preload scanner`가 읽어 `LCP`로 빠르게 가져가는 것이 좋다.
- `LCP`는 직접 호스팅
  - 다른 origin에서 이미지를 가져오는 것은 최적화에 좋은 영향이 아님
  - 중요한 리소스는 직접 다루고, 덜 중요한 리소스만 이미지 최적화 서비스를 사용할 것

## 12.4 최초 입력 지연 (FID)

### 정의

> 사용자가 페이지와 처음 상호 작용할 때부터 해당 상호 작용에 대한 응답으로 브라우저가 실제로 이벤트 핸들러 처리를 시작하기까지의 시간

- 최초의 입력 하나에 대해서만 응답 지연을 판단

### 의미

- 보통 웹 이벤트가 느린 이유는, 해당 작업을 처리하는 브라우저의 메인 스레드가 바쁘기 때문
  - 대규모 렌더링
  - 대규모 자바스크립트 파일 분석

> 자바스크립트는 싱글 스레드이기 때문에, 메인 스레드가 다른 작업을 하고 있다면 지연이 발생한다.

- 구글의 사용자 경험 4가지 분류 `RAIL`
  - `Response` : 사용자의 입력에 대한 반응속도, 50ms 미만으로 이벤트 처리할 것
  - `Animation` : 애니메이션의 각 프레임을 10ms 이하로 잡을 것
  - `Idle` : 페이지가 50ms 이내에 사용자 입력에 응답할 것
  - `Load` : 5초 이내에 콘텐츠를 전달하고 인터렉션을 준비할 것

→ 여기서 `FID`는 `Response`에 초점을 맞추고 있다.

즉, `FID`는 화면이 최초 그려진 후, 사용자가 클릭 등의 상호작용을 했을 때, 메인 스레드가 해당 이벤트의 반응을 할 수 있을 때까지의 시간

※ 이벤트 핸들러가 완료되는 데 걸리는 시간은 측정하지 않는다.

### 기준 점수

- 100ms 내로 응답이 오면 `Good`
- 300ms 내로 응답이 오면 `Needs Improvement`
- 그 이상 `Poor`

### 개선 방안

- 메인 스레드에 이벤트를 실행할 여유가 필요하다.
  - 개발자 도구에서 메인 스레드 처리가 오래 걸리는 작업이 있다면 [Long task](https://developer.mozilla.org/ko/docs/Glossary/Long_task) 경고가 발생한다.
    - mozilla에서는 이를 50ms 이상으로 정의한다.

1. 꼭 웹페이지에서 해야하는 작업인가?
   - 보통 사용자의 기기는 개발자 기기보다 성능이 좋지 않다.
   - 꼭 클라이언트 단에서 처리해야하는 작업이 아니라면, 서버단에서 처리하자.
2. 긴 작업을 여러 개로 분리해보자
   - 긴 작업 하나가 스레드를 오래 점유하면, 그동안 사용자는 응답을 받을 수 없다.
   - 긴 작업 또는 최초 로딩에 필요하지 않은 내용을 불러오는 것들은 분리하거나 나중에 처리하자.
     - `Suspense`, `lazy`, `dynamic` ...

※ 현대 자바스크립트 번들러는 코드 번들링에 필요한 코드만 모아 프로덕션 코드를 생성한다.

### 폴리필 `polyfill`

> 브라우저에서 지원하지 않는 기능을 사용하기 위해 웹페이지에서 직접 구현하고 집어넣는 코드

e.g. `Array.prototype.find`는 IE 11 이하에서는 지원하지 않기 때문에 폴리필이 필요하다. ~~어차피 IE는 죽었다~~

- 확인해야 할 점
  1. 폴리필이 필요한 환경인가?
  2. 꼭 필요한 폴리필인가?
  - 자주 사용하지 않는다면 직접 코드를 구현하자
- 바벨을 사용한다면, `@babel/preset-env`를 사용하면 좋다.
- Next의 `SWC`를 사용한다면, 이미 내부에 구현이 되어있다. ~~캬~~

#### 타사 스크립트

- 타사 스크립트는 대부분 웹페이지 로드에 중요하지 않으므로, `<script>`의 `async`, 가능하다면 `defer`를 사용해 `lazy loading`을 적용하자.
  - `defer` : 해당 스크립트를 다른 리소스와 함께 **병렬 다운로드**한다. 이후 페이지가 완전히 로딩된 후 맨 마지막에 실행한다.
  - `async` : 마찬가지로 **병렬 다운로드**. 다운로드가 완료되면 바로 실행한다.
  - 일반 `script` : 만나는 순간 바로 바운로드 우선 실행

※ 만약 광고 등의 뷰포트에 영향을 받는 컴포넌트라면 `Intersection Observer`를 사용하자.

## 12.5 누적 레이아웃 이동 (CLS)

### 정의

> 페이지의 생명주기 동안 발생하는 모든 예기치 않은 이동에 대한 지표

- 해당 지표가 낮으면 예상치 못한 레이아웃이 적은, 더 좋은 웹사이트다.

### 의미

```tsx
<img src="URL" />
```

- 위의 이미지는 이미지를 불러오는 과정에서 reflow가 일어나며 레이아웃 시프팅 현상이 발생한다.

이는 이미지 크기를 미리 지정하는 방식으로 reflow를 방지하여 해결할 수 있다.

(또 다른 방법으로는 스켈레톤 기법이 있다.)

```tsx
<img src="URL" width="600" height="300" />
```

이와 관련된 `Layout Shift` 문제는 [이 글](https://www.smashingmagazine.com/2020/03/setting-height-width-images-important-again/)에서 더 자세하게 다룬다.

- Next의 `Image` 컴포넌트는 `width` 와 `height` 프로퍼티가 필수 값이기 때문에, 이러한 문제를 자동으로 해결할 수 있다.

### 기준 점수

- 0.1 이하면 `Good`
- 0.25 이하면 `Needs Improvement`
- 그 이상 `Poor`

### 개선 방안

1. 위처럼 예상되는 요소의 추가 공간을 확보한다.
   - 가장 좋은 방법은 서버 사이드 렌더링을 활용하는 것
2. 폰트 로딩 최적화
   - Flash Of Unstyled Text `FOUT` : 지정한 폰트 대신 기본 대체 폰트가 보이다가, 뒤늦게 폰트가 적용되는 현상
   - Flash Of Invisible Text `FOIT` : 기본 폰트도 없어 텍스트가 없다가, 뒤늦게 폰트가 로딩되어 렌더링되는 현상
   - → 최대한 중요한 폰트의 다운로드를 우선 순위에 넣고, 그래도 빠른 로딩에 실패하면 기본 폰트를 노출

### 핵심 웹 지표는 아니지만 성능 확인에 중요한 지표들

#### 최초 바이트까지의 시간 (Time To First Byte `TTFB`)

> 브라우저가 웹페이지의 첫 번째 바이트를 수신하는 데 걸리는 시간

보통 SSR 환경에서 주의깊게 보아야 할 지표

서버에서 첫 HTML 문서를 만드는 데 필요한 시간이 오래 걸릴수록 `TTFB`가 길어지게 된다. (600ms 이상이면 개선 필요)

- 개선 방법
  - SSR 로직 최적화
  - 사용자 위치를 파악하여, 최대한 해당 위치와 가까운 서버를 배치
    - `AWS`에서는 한국 사용자에겐 `us-east` 보다 `ap` (아시아), 특히 `ap-northeast-2` (서울) 이 제일 낫다.
  - React SSR의 경우, ~~`renderToNodeStream`, `renderToStaticNodeStream`~~, `renderToPipeableStream` 등의 스트리밍 API를 사용해볼 것

<img width="1392" alt="image" src="https://github.com/user-attachments/assets/3ae9dcaa-1f9a-4fae-be39-01a8b48d2428">

#### 최초 콘텐츠풀 페인트 (First Contentful Paint `FCP`)

> 페이지가 로드되기 시작한 시점부터 페이지 콘텐츠의 일부가 화면에 렌더링될 때까지의 시간

- 이미지, 텍스트, svg 등, 뭐라도 뜨기 시작한 시점까지의 시간

- 기준 점수
  - 1.8초 이내이면 `Good`,
  - 3.0초 이내이면 `Needs Improvement`,
  - 그 이후 `Poor`
  - ~~[뭔가 좀 다른 점수](https://web.dev/articles/fcp)~~

<img width="1275" alt="image" src="https://github.com/user-attachments/assets/2e97745e-e5c3-41aa-9bfa-b734024048e8">
